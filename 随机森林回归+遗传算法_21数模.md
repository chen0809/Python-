## 随机森林回归

```python
# 加载库
import pandas as pd
import numpy as np
import copy
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import cross_val_score

# 创建随机森林回归对象
randomforest = RandomForestRegressor(random_state=0, n_jobs=-1)

# 训练模型
model = randomforest.fit(features, target) # (自变量，应变量)

# 计算特征的重要性
importances = model.feature_importances_

# 交叉验证
cv_mse = cross_val_score(model, features, target, scoring='neg_mean_squared_error', cv=10)
```

## GA遗传算法

```python
import numpy as np
import pandas as pd

def F(feature_data, model):
    return model.predict(feature_data)

# 计算适应度-最小值
def get_fitness(pop, model): 
    data_df = translateDNA(pop, garf_d)
    pred = F(data_df, model) # 适应度
    return (pred - np.min(pred)) + 1e-3 #减去最小的适应度是为了防止适应度出现负数，通过这一步fitness的

# 解码
def translateDNA(pop, garf_d): #pop表示种群矩阵，一行表示一个二进制编码表示的DNA，矩阵的行数为种群数目
    #pop:(POP_SIZE,DNA_SIZE)*(DNA_SIZE,1) --> (POP_SIZE,1)
    data_df = pd.DataFrame()
    for i in range(239):      
        x_pop = pop[:,i::239] # 每间隔238位为同一个特征的编码，共24位
        X_BOUND = [garf_d.iloc[:,i+3].min(), garf_d.iloc[:,i+3].max()] # 将二进制解码范围限定在特征的最大最小值之间
        data_df['%s' %i] = x_pop.dot(2**np.arange(DNA_SIZE)[::-1])/float(2**DNA_SIZE-1)*(X_BOUND[1]-X_BOUND[0])+X_BOUND[0]
        # np.arange(DNA_SIZE)[::-1]生成23到0的倒序数列
    return data_df

# 遗传
def crossover_and_mutation(pop, CROSSOVER_RATE = 0.8):
    new_pop = []
    for father in pop:        #遍历种群中的每一个个体，将该个体作为父亲
        child = father        #孩子先得到父亲的全部基因（这里我把一串二进制串的那些0，1称为基因）
        if np.random.rand() < CROSSOVER_RATE:            #产生子代时不是必然发生交叉，而是以一定的概率发生交叉
            mother = pop[np.random.randint(POP_SIZE)]    #在种群中选择另一个个体，并将该个体作为母亲
            cross_points = np.random.randint(low=0, high=DNA_SIZE*239)    #随机产生交叉的点
            child[cross_points:] = mother[cross_points:]        #孩子得到位于交叉点后的母亲的基因
        mutation(child) #每个后代有一定的机率发生变异
        new_pop.append(child)

    return new_pop

# 变异
def mutation(child, MUTATION_RATE=0.003):
    if np.random.rand() < MUTATION_RATE:  #以MUTATION_RATE的概率进行变异
        mutate_point = np.random.randint(0, DNA_SIZE*239) #随机产生一个实数，代表要变异基因的位置
        child[mutate_point] = child[mutate_point]^1  #将变异点的二进制为反转

# 选择
def select(pop, fitness):    # nature selection wrt pop's fitness
    idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=(fitness)/(fitness.sum()))
    return pop[idx] 

# 寻找最优解
def get_final_fitness(pop, model): 
    data_df = translateDNA(pop, garf_d)
    pred = F(data_df, rf_model)
    return np.max(pred), np.argmax(pred)

def print_info(pop):
    fitness, max_index = get_final_fitness(pop, model)
    print("max_fitness:", fitness)
    data_df = translateDNA(pop, garf_d)
    print("最优的基因型：", pop[max_index])
    for i in range(239):
        print(data_df.iloc[max_index, :])
```

```python
DNA_SIZE = 24 # DNA编码长度（自定义）
POP_SIZE = 632 # 群体大小
CROSSOVER_RATE = 0.8 # 交叉概率
MUTATION_RATE = 0.005 # 变异概率
N_GENERATIONS = 100 # 子代数目

if __name__ == "__main__":
    # 生成初始种群
    pop = np.random.randint(2, size=(POP_SIZE, DNA_SIZE*239)).reshape(POP_SIZE,1) # 一个特征有一个DNA，matrix (POP_SIZE, DNA_SIZE)
    for _ in range(N_GENERATIONS):#迭代N代
        data_df = translateDNA(pop, garf_d) # 解码
        pop = np.array(crossover_and_mutation(pop, CROSSOVER_RATE)) # 遗传、交叉、变异，生成新的一代
        #F_values = F(translateDNA(pop)[0], translateDNA(pop)[1])#x, y --> Z matrix
        fitness = get_fitness(pop, model) # 用新的子代进行预测
        pop = select(pop, fitness) #选择生成新的种群
    
    print_info(pop) 
```

garf_d数据前5行数据

![](C:\Users\10630\AppData\Roaming\Typora\typora-user-images\image-20220301201014028.png)

